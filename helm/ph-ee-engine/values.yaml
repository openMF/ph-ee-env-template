ingress:
  apiversion: "networking.k8s.io/v1"

deployment:
  apiversion: "apps/v1"

service:
  apiversion: "v1"

secret:
  apiversion: "v1"

configmap:
  apiversion: "v1"  

global:
  bucket_name: paymenthub-ee
  region: "ap-south-1"
  s3BaseUrl: "http://minio:9000"
  SPRING_PROFILES_ACTIVE: "bb"
  imagePullPolicy: "Always"
  LOGGING_LEVEL_ROOT: "INFO"
  LOGGING_PATTERN_CONSOLE: "%d{dd-MM-yyyy HH:mm:ss.SSS} %magenta([%thread]) %highlight(%-5level) %logger.%M - %msg%n"
  tenants: ""
  DFSPIDS: ""
  max_execution_threads: 50
  poll_interval: 10
camunda-platform:
  connectors:
    enabled: false
  global:
    zeebe: "{{ .Release.Name }}-zeebe"
    elasticsearch:
      disableExporter: true
      host: "ph-ee-elasticsearch"
    identity:
      auth:
        enabled: false

  zeebe:
    enabled: true
    env:
      #    - name: ZEEBE_BROKER_BACKPRESSURE_ENABLED
      #      value: "false"
      - name: ZEEBE_BROKER_EXECUTION_METRICS_EXPORTER_ENABLED
        value: "true"
      - name: ZEEBE_BROKER_EXPORTERS_ELASTICSEARCH_CLASSNAME
        value: "hu.dpc.rt.kafkastreamer.exporter.NoOpExporter"
      - name: ZEEBE_BROKER_EXPORTERS_ELASTICSEARCH_JARPATH
        value: "/exporters/ph-ee-kafka-exporter.jar"
      - name: ZEEBE_BROKER_EXPORTERS_KAFKA_JARPATH
        value: "/exporters/ph-ee-kafka-exporter.jar"
      - name: ZEEBE_BROKER_EXPORTERS_KAFKA_CLASSNAME
        value: "hu.dpc.rt.kafkastreamer.exporter.KafkaExporter"
      - name: ZEEBE_BROKER_BACKPRESSURE_VEGAS_INITIALLIMIT
        value: "1000"
      - name: ZEEBE_BROKER_BACKPRESSURE_VEGAS_ALPHA
        value: "2"
      - name: ZEEBE_BROKER_BACKPRESSURE_VEGAS_BETA
        value: "8"
      - name: ZEEBE_BROKER_EXPORTERS_KAFKA_ARGS_INDEX_EVENT
        value: 'true'
      - name: ZEEBE_BROKER_EXPORTERS_KAFKA_ARGS_INDEX_VARIABLE
        value: 'true'
      - name: ZEEBE_BROKER_EXPORTERS_KAFKA_ARGS_INDEX_PROCESSINSTANCE
        value: 'true'
      - name: ZEEBE_BROKER_EXPORTERS_KAFKA_ARGS_INDEX_PROCESS
        value: 'true'
      - name: ZEEBE_BROKER_EXPORTERS_KAFKA_ARGS_INDEX_INCIDENT
        value: 'true'
      - name: ZEEBE_BROKER_EXPORTERS_KAFKA_ARGS_INDEX_DEPLOYMENT
        value: 'false'
      - name: ZEEBE_BROKER_EXPORTERS_KAFKA_ARGS_INDEX_ERROR
        value: 'false'
      - name: ZEEBE_BROKER_EXPORTERS_KAFKA_ARGS_INDEX_JOB
        value: 'false'
      - name: ZEEBE_BROKER_EXPORTERS_KAFKA_ARGS_INDEX_VARIABLEDOCUMENT
        value: 'false'
      - name: ZEEBE_BROKER_EXPORTERS_KAFKA_ARGS_INDEX_WORKFLOWINSTANCE
        value: 'false'
      - name: ZEEBE_BROKER_EXPORTERS_KAFKA_ARGS_INDEX_CREATETEMPLATE
        value: 'false'

    extraInitContainers:
      - name: init-ph-ee-kafka-exporter
        image: busybox:1.28
        command: ['/bin/sh', '-c']
        args: ['wget -O /exporters/ph-ee-kafka-exporter.jar "https://fynarfin.io/images/exporter-3.0.0-SNAPSHOT.jar"; ls -al /exporters/']
        volumeMounts:
          - name: exporters
            mountPath: /exporters/
    volumeClaimTemplate:
      storageClassName: "gp2"

    image:
      repository: camunda/zeebe
      tag: 8.2.8
    clusterSize: "1"
    partitionCount: "1"
    replicationFactor: "1"
    cpuThreadCount: "2"
    ioThreadCount: "2"
    pvcSize: "10Gi"

    resources:
      requests:
        cpu: 100m

  zeebe-gateway:
    replicas: 1
    logLevel: warn
    env:
      - name: ZEEBE_GATEWAY_THREADS_MANAGEMENTTHREADS
        value: "4"
      - name: ZEEBE_GATEWAY_MONITORING_ENABLED
        value: "true"

  elasticsearch:
    enabled: false
    fullnameOverride: "zeebe-elasticsearch"
    clusterName: "zeebe-elasticsearch"

  operate:
    enabled: false

  tasklist:
    enabled: false
  optimize:
    enabled: false
  prometheusServiceMonitor:
    enabled: true
  identity:
    enabled: false

elasticsearch:
  enabled: true
  # imageTag: 7.17.1
  replicas: 1
  protocol: http
  fullnameOverride: "ph-ee-elasticsearch"
  clusterName: "ph-ee-elasticsearch"
  minimumMasterNodes: 1
  esConfig:
    elasticsearch.yml: |
      xpack.security.enabled: false
      xpack.security.transport.ssl.enabled: false
      xpack.security.transport.ssl.verification_mode: certificate
      xpack.security.transport.ssl.keystore.path: /usr/share/elasticsearch/config/certs/elastic-certificates.p12
      xpack.security.transport.ssl.truststore.path: /usr/share/elasticsearch/config/certs/elastic-certificates.p12
      xpack.security.http.ssl.enabled: false
      xpack.security.http.ssl.truststore.path: /usr/share/elasticsearch/config/certs/elastic-certificates.p12
      xpack.security.http.ssl.keystore.path: /usr/share/elasticsearch/config/certs/elastic-certificates.p12
  secretMounts:
    - name: elastic-certificates
      secretName: elastic-certificates
      path: /usr/share/elasticsearch/config/certs
  extraEnvs:
    - name: ELASTIC_PASSWORD
      valueFrom:
        secretKeyRef:
          name: elastic-credentials
          key: password


kibana:
  enabled: true
  imageTag: 7.16.3
  fullnameOverride: "ph-ee-kibana"
  elasticsearchHosts: "http://ph-ee-elasticsearch:9200/"
  protocol: http
  kibanaConfig:
    kibana.yml: |
      monitoring.enabled: false
      xpack.encryptedSavedObjects.encryptionKey: 5f4dcc3b5aa765d61d8327deb882cf99
      server.ssl:
        enabled: false
        key: /usr/share/kibana/config/certs/elastic-certificate.pem
        certificate: /usr/share/kibana/config/certs/elastic-certificate.pem
      xpack.security.encryptionKey: ${KIBANA_ENCRYPTION_KEY}
      elasticsearch.ssl:
        certificateAuthorities: /usr/share/kibana/config/certs/elastic-certificate.pem
        verificationMode: certificate
  secretMounts:
    - name: elastic-certificate-pem
      secretName: elastic-certificate-pem
      path: /usr/share/kibana/config/certs
  extraEnvs:
    - name: 'ELASTICSEARCH_USERNAME'
      valueFrom:
        secretKeyRef:
          name: elastic-credentials
          key: username
    - name: 'ELASTICSEARCH_PASSWORD'
      valueFrom:
        secretKeyRef:
          name: elastic-credentials
          key: password
    - name: 'KIBANA_ENCRYPTION_KEY'
      valueFrom:
        secretKeyRef:
          name: kibana
          key: encryptionkey


channel:
  enabled: false
  replicas: 1
  image: docker.io/openmf/ph-ee-connector-channel:v1.9.0
  imagePullPolicy: "Always"
  TRANSACTION_ID_LENGTH: 20
  gsma_payee_tenant: ""
  redis:
    host: "127.0.0.1"
    port: 6379
    password: ""
    idempotency:
      enabled: true
      keyFormat: "clientCorrelationId_tenant_api"
      apiList: "/channel/transfer,/channel/collection,/channel/gsma/transaction,/channel/transactionRequest"
  operations:
    url: "http://ph-ee-operations-app:80/api/v1"
    authEnabled: false
  tenantPrimary:
    clientId: ""
    clientSecret: ""
    tenant: ""
  tenantSecondary:
    clientId: ""
    clientSecret: ""
    tenant: ""
  livenessProbe:
    httpGet:
      path: /actuator/health/liveness
      port: 8443
      scheme: HTTPS 
    initialDelaySeconds: 120
    periodSeconds: 30
    failureThreshold: 3
    timeoutSeconds: 5 
  readinessProbe:
    httpGet:
      path: /actuator/health/readiness
      port: 8443
      scheme: HTTPS
    initialDelaySeconds: 120
    periodSeconds: 30
    failureThreshold: 3
    timeoutSeconds: 5
# Whether this chart should self-manage its service account, role, and associated role binding.
  managedServiceAccount: true 
# Custom service account override that the pod will use
  serviceAccount: "channel" 
# Annotations to add to the ServiceAccount that is created if the serviceAccount value isn't set.
  serviceAccountAnnotations: {} 
# How long to wait for channel pods to stop gracefully
  terminationGracePeriod: 30 
# Extra environment variables for channel container.
  envFrom: [] 
  # - configMapRef:
  #     name: config-secret
  extraEnvs: []
# This is the PriorityClass settings as defined in
# https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/#priorityclass  
  priorityClassName: "" 
  # ph-ee-connector-channelConfig: ""
  #   ph-ee-connector-channel: |
  # - User that the container will execute as.
  # Not necessary to run as root (0) as the channel Deployment use cases do not need access to Kubernetes Node internals
  # - Typically not necessarily unless running within environments such as OpenShift.
  securityContext:
    runAsUser: 0
    privileged: false
  resources:    
    limits:
      memory: "512M"
      cpu: "500m"
    requests:
      memory: "512M"
      cpu: "100m"
  service:
    annotations: {}
# Enabling this will publicly expose your channel instance.
# Only enable this if you have security enabled on your cluster    
  ingress:
    enabled: true
    path: "/channel"
    annotations: {}
    backend: {}
    stub_backend: {}
  deployment:
    annotations: {}
    affinity: {}
    nodeSelector: {}
    tolerations: []
    envFrom: []
  # - configMapRef:
  #     name: config-secret
    extraEnvs: []
  # - User that the container will execute as.
  # Not necessary to run as root (0) as the channel Deployment use cases do not need access to Kubernetes Node internals
  # - Typically not necessarily unless running within environments such as OpenShift.
    securityContext:
      runAsUser: 0
      privileged: false
    resources:    
      limits:
        memory: "512M"
        cpu: "500m"
      requests:
        memory: "512M"
        cpu: "100m"
# Allows you to add any config files in /usr/share/
    # such as ph-ee-connector-channel.yml for deployment  
    # ph-ee-connector-channelConfig: {}
    #   ph-ee-connector-channel.yml: |        

operations:
  enabled: true
  mysql:
    enabled: true

operationsmysql:
  fullnameOverride: "operationsmysql"
  image:
    tag: "5.7"
    debug: false
  auth:
    database: "tenants"
    username: "mifos"
    password: "password"
    rootPassword: "4ET6ywqlGt"
  initdbScripts:
    setup.sql: |-
      CREATE DATABASE IF NOT EXISTS phdefault;
      CREATE DATABASE IF NOT EXISTS messagegateway;
      CREATE DATABASE `voucher_management`
      GRANT ALL ON *.* TO 'root'@'%';
      GRANT ALL PRIVILEGES ON messagegateway.* TO 'mifos';
      GRANT ALL PRIVILEGES ON phdefault.* TO 'mifos';
      GRANT ALL PRIVILEGES ON `voucher_management`.* TO 'mifos';
  volumeClaimTemplate:
    storageClassName: "gp2"

ph_ee_connector_ams_mifos:
  enabled: false
  replicas: 1
  image: docker.io/openmf/ph-ee-connector-ams-mifos:v1.3.0
  imagePullPolicy: "Always"
  ams_local_enabled: true
  ams_local_interop_host: "fineract-server"
  ams_local_account_host: "fineract-server"
  ams_local_customer_host: "fineract-server"
  ams_local_auth_host: "fineract-server"
  ams_local_tenants: ""
  ams_local_loan_host: ""
# Whether this chart should self-manage its service account, role, and associated role binding.
  managedServiceAccount: true 
# Custom service account override that the pod will use
  serviceAccount: "" 
# Annotations to add to the ServiceAccount that is created if the serviceAccount value isn't set.
  serviceAccountAnnotations: {} 
# How long to wait for ams-mifos pods to stop gracefully
  terminationGracePeriod: 180
# Extra environment variables for ams-mifos container.
  envFrom: [] 
  # - configMapRef:
  #     name: config-secret
  extraEnvs: []
# This is the PriorityClass settings as defined in
# https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/#priorityclass  
  priorityClassName: "" 
  # ph-ee-connector-ams-mifosConfig: ""
  #   ph-ee-connector-ams-mifos.yml: |
  # - User that the container will execute as.
  # Not necessary to run as root (0) as the ams-mifos Deployment use cases do not need access to Kubernetes Node internals
  # - Typically not necessarily unless running within environments such as OpenShift.
  securityContext:
    runAsUser: 0
    privileged: false
  resources:    
    limits:
      memory: "384M"
      cpu: "500m"
    requests:
      memory: "256M"
      cpu: "300m"
# Enabling this will publicly expose your ams-mifos instance.
# Only enable this if you have security enabled on your cluster    
  ingress:
    enabled: false 
    annotations: {}
      
  deployment:
    annotations: {}
    affinity: {}
    nodeSelector: {}
    tolerations: []
    envFrom: []
  # - configMapRef:
  #     name: config-secret
    extraEnvs: []
  # - User that the container will execute as.
  # Not necessary to run as root (0) as the zeebeops Deployment use cases do not need access to Kubernetes Node internals
  # - Typically not necessarily unless running within environments such as OpenShift.
    securityContext:
      runAsUser: 0
      privileged: false
    resources:    
      limits:
        memory: "512M"
        cpu: "500m"
      requests:
        memory: "512M"
        cpu: "100m"    
# Allows you to add any config files in /usr/share/
    # such as ph-ee-connector-ams-mifos.yml for deployment  
    # ph-ee-connector-ams-mifosConfig: {}
    #   ph-ee-connector-ams-mifos.yml: | 

ph_ee_connector_mojaloop:
  enabled: false
  replicas: 1
  image: docker.io/openmf/ph-ee-connector-mojaloop:v1.3.0
  imagePullPolicy: "Always"
  hostname: ""
  switch:
    quotes:
      host: ""
      service: ""
    als:
      host: ""
      service: ""
    transfers:
      host: ""
      service: ""
    transactions:
      host: ""
      service: ""
    oracle:
      host: ""
  livenessProbe:
    httpGet:
      path: /actuator/health/liveness
      port: 9191
    initialDelaySeconds: 120
    periodSeconds: 30
    failureThreshold: 3
    timeoutSeconds: 5 
  readinessProbe:
    httpGet:
      path: /actuator/health/readiness
      port: 9191
    initialDelaySeconds: 120
    periodSeconds: 30
    failureThreshold: 3
    timeoutSeconds: 5
# Whether this chart should self-manage its service account, role, and associated role binding.
  managedServiceAccount: true 
# Custom service account override that the pod will use
  serviceAccount: "" 
# Annotations to add to the ServiceAccount that is created if the serviceAccount value isn't set.
  serviceAccountAnnotations: {} 
# How long to wait for mojaloop pods to stop gracefully
  terminationGracePeriod: 30 
# Extra environment variables for mojaloop container.
  envFrom: [] 
  # - configMapRef:
  #     name: config-secret
  extraEnvs: []
# This is the PriorityClass settings as defined in
# https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/#priorityclass  
  priorityClassName: "" 
  # ph-ee-connector-mojaloop-javaConfig: ""
  #   ph-ee-connector-mojaloop-java.yml: |
  # - User that the container will execute as.
  # Not necessary to run as root (0) as the mojaloop Deployment use cases do not need access to Kubernetes Node internals
  # - Typically not necessarily unless running within environments such as OpenShift.
  securityContext:
    runAsUser: 0
    privileged: false
  resources:    
    limits:
      memory: "512M"
      cpu: "500m"
    requests:
      memory: "512M"
      cpu: "100m"           
# Enabling this will publicly expose your mojaloop instance.
# Only enable this if you have security enabled on your cluster    
  ingress:
    enabled: true
    path: "/"
    annotations: {}
    backend: {}
  deployment:
    annotations: {}
    affinity: {}
    nodeSelector: {}
    tolerations: []
    envFrom: []
  # - configMapRef:
  #     name: config-secret
    extraEnvs: []
  # - User that the container will execute as.
  # Not necessary to run as root (0) as the mojaloop Deployment use cases do not need access to Kubernetes Node internals
  # - Typically not necessarily unless running within environments such as OpenShift.
    securityContext:
      runAsUser: 0
      privileged: false
    resources:    
      limits:
        memory: "512M"
        cpu: "500m"
      requests:
        memory: "512M"
        cpu: "100m"    
# Allows you to add any config files in /usr/share/
    # such as ph-ee-connector-mojaloop-java.yml for deployment  
    # ph-ee-connector-mojaloop-javaConfig: {}
    #   ph-ee-connector-mojaloop-java.yml: |

operations_app:
  enabled: true
  replicas: 1
  image: docker.io/openmf/ph-ee-operations-app:v1.10.0
  imagePullPolicy: "Always"
  token_client_channel_secret: ""
  minio_public_host: "http://minio:9000"
  datasource:
      username: "mifos"
      password: "password"
      host: "operationsmysql"
      port: 3306
      schema: "tenants"
  livenessProbe:
    httpGet:
      path: /actuator/health/liveness
      port: 9191
    initialDelaySeconds: 120
    periodSeconds: 30
    failureThreshold: 3
    timeoutSeconds: 5 
  readinessProbe:
    httpGet:
      path: /actuator/health/readiness
      port: 9191
    initialDelaySeconds: 120
    periodSeconds: 30
    failureThreshold: 3
    timeoutSeconds: 5
# Whether this chart should self-manage its service account, role, and associated role binding.
  managedServiceAccount: true 
# Custom service account override that the pod will use
  serviceAccount: "" 
# Annotations to add to the ServiceAccount that is created if the serviceAccount value isn't set.
  serviceAccountAnnotations: {} 
# How long to wait for operations_app pods to stop gracefully
  terminationGracePeriod: 30 
# Extra environment variables for operations_app container.
  envFrom: [] 
  # - configMapRef:
  #     name: config-secret
  extraEnvs: []
# This is the PriorityClass settings as defined in
# https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/#priorityclass  
  priorityClassName: "" 
# operations_appConfig: ""
#   operations_app.yml: |
# - User that the container will execute as.
# Not necessary to run as root (0) as the operations_app Deployment use cases do not need access to Kubernetes Node internals
# - Typically not necessarily unless running within environments such as OpenShift.
  securityContext:
    runAsUser: 0
    privileged: false
  resources:    
    limits:
      memory: "512M"
      cpu: "500m"
    requests:
      memory: "512M"
      cpu: "100m"
# Enabling this will publicly expose your operations_app instance.
# Only enable this if you have security enabled on your cluster       
  ingress:
    enabled: false
    path: "/opsapp"
    annotations: {}
    backend: {}
  deployment:
    annotations: {}
    affinity: {}
    nodeSelector: {}
    tolerations: []
    envFrom: []
  # - configMapRef:
  #     name: config-secret
    extraEnvs: []
# - User that the container will execute as.
# Not necessary to run as root (0) as the operations_app Deployment use cases do not need access to Kubernetes Node internals
# - Typically not necessarily unless running within environments such as OpenShift.
    securityContext:
      runAsUser: 0
      privileged: false
    resources:    
      limits:
        memory: "512M"
        cpu: "500m"
      requests:
        memory: "512M"
        cpu: "100m"    
# Allows you to add any config files in /usr/share/
    # such as operations_app.yml for deployment

operations_web:
  enabled: true
  replicas: 1
  image: docker.io/openmf/ph-ee-operations-web:v1.10.0
  imagePullPolicy: "Always"
  imagePullSecrets: []
  webhost: ""
  livenessProbe:
    httpGet:
      path: /actuator/health/liveness
      port: 9191
    initialDelaySeconds: 120
    periodSeconds: 30
    failureThreshold: 3
    timeoutSeconds: 5 
  readinessProbe:
    httpGet:
      path: /actuator/health/readiness
      port: 9191
    initialDelaySeconds: 120
    periodSeconds: 30
    failureThreshold: 3
    timeoutSeconds: 5
# Whether this chart should self-manage its service account, role, and associated role binding.
  managedServiceAccount: true 
# Custom service account override that the pod will use
  serviceAccount: "" 
# Annotations to add to the ServiceAccount that is created if the serviceAccount value isn't set.
  serviceAccountAnnotations: {} 
# How long to wait for operations_web pods to stop gracefully
  terminationGracePeriod: 30 
# Extra environment variables for operations_web container.
  envFrom: [] 
  # - configMapRef:
  #     name: config-secret
  extraEnvs: []
# This is the PriorityClass settings as defined in
# https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/#priorityclass  
  priorityClassName: "" 
# ph-ee-operations-web-configConfig: ""
#   ph-ee-operations-web-config.yml: |
# - User that the container will execute as.
# Not necessary to run as root (0) as the operations_web Deployment use cases do not need access to Kubernetes Node internals
# - Typically not necessarily unless running within environments such as OpenShift.
  securityContext:
    runAsUser: 0
    privileged: false
  resources:    
    limits:
      memory: "512M"
      cpu: "500m"
    requests:
      memory: "512M"
      cpu: "100m"       
# Enabling this will publicly expose your operations_web instance.
# Only enable this if you have security enabled on your cluster      
  ingress:
    enabled: false
    path: "/"
    annotations: {}    
    backend: {}
  deployment:
    config:
      - name: ph-ee-operations-web-config
        mountPath: "/usr/share/nginx/html/assets/configuration.properties"
        subPath: "configuration.properties"
    annotations: {}
    affinity: {}
    nodeSelector: {}
    tolerations: []
    envFrom: []
  # - configMapRef:
  #     name: config-secret
    extraEnvs: []
# - User that the container will execute as.
# Not necessary to run as root (0) as the operation-web Deployment use cases do not need access to Kubernetes Node internals
# - Typically not necessarily unless running within environments such as OpenShift.
    securityContext:
      runAsUser: 0
      privileged: false
    resources:    
      limits:
        memory: "512M"
        cpu: "500m"
      requests:
        memory: "512M"
        cpu: "100m"    
# Allows you to add any config files in /usr/share/
    # such as ph-ee-operations-web.yml for deployment
    # ph-ee-operations-webConfig: {}
    #   ph-ee-operations-web.yml: |          

identity:

mpesa:
  enabled: false
  replicas: 1
  image: "docker.io/openmf/ph-ee-connector-mpesa"
  imageTag: "v1.6.0"
  zeebe_init_transfer_wait_timer: 10
  tenant: ""
  serviceAccountName: ""
  callback_host: ""
  channel:
    host: ""
  paygops:
    host: ""
  roster:
    host: ""
  accounts:
    default:
      name: "default"
      business_short_code: "7385028"
      till: "1234567"
      auth_host: "https://sandbox.safaricom.co.ke/oauth/v1/generate"
      api_host: "https://sandbox.safaricom.co.ke"
      client_key: "0pLxbN83FrOl5Nd0Fh9Zi5BQlMxSL2n5"
      client_secret: "YzuGNoJxeub8ZC6d"
      pass_key: "bfb279f9aa9bdbcf158e97dd71a467cd2e0c893059b10f78e6b72ada1ed2c919"
    roster:
      name: "roster"
      business_short_code: "7385028"
      till: "1234567"
      auth_host: "https://sandbox.safaricom.co.ke/oauth/v1/generate"
      api_host: "https://sandbox.safaricom.co.ke"
      client_key: "0pLxbN83FrOl5Nd0Fh9Zi5BQlMxSL2n5"
      client_secret: "YzuGNoJxeub8ZC6d"
      pass_key: "bfb279f9aa9bdbcf158e97dd71a467cd2e0c893059b10f78e6b72ada1ed2c919"
    paygops:
      name: "paygops"
      business_short_code: "174379"
      till: "9347335"
      auth_host: "https://sandbox.safaricom.co.ke/oauth/v1/generate"
      api_host: "https://sandbox.safaricom.co.ke"
      client_key: "0pLxbN83FrOl5Nd0Fh9Zi5BQlMxSL2n5"
      client_secret: "YzuGNoJxeub8ZC6d"
      pass_key: "bfb279f9aa9bdbcf158e97dd71a467cd2e0c893059b10f78e6b72ada1ed2c919"
  
  paybill:
    accountHoldingInstitutionId: "default"
    paygops:
      business_short_code: "24322607"
      currency: "KES"
    roster:
      business_short_code: "12345678"
      currency: "KES"
  livenessProbe:
    httpGet:
      path: /actuator/health/liveness
      port: 9191
    initialDelaySeconds: 120
    periodSeconds: 30
    failureThreshold: 3
    timeoutSeconds: 5 
  readinessProbe:
    httpGet:
      path: /actuator/health/readiness
      port: 9191
    initialDelaySeconds: 120
    periodSeconds: 30
    failureThreshold: 3
    timeoutSeconds: 5
# Whether this chart should self-manage its service account, role, and associated role binding.
  managedServiceAccount: true 
# Custom service account override that the pod will use
  serviceAccount: "" 
# Annotations to add to the ServiceAccount that is created if the serviceAccount value isn't set.
  serviceAccountAnnotations: {} 
# How long to wait for mpesa pods to stop gracefully
  terminationGracePeriod: 30 
# Extra environment variables for mpesa container.
  envFrom: [] 
  # - configMapRef:
  #     name: config-secret
  extraEnvs: []
# This is the PriorityClass settings as defined in
# https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/#priorityclass  
  priorityClassName: "" 
  # ph-ee-connector-mpesaConfig: ""
  #   ph-ee-connector-mpesa.yml: |
  # - User that the container will execute as.
  # Not necessary to run as root (0) as the mpesa Deployment use cases do not need access to Kubernetes Node internals
  # - Typically not necessarily unless running within environments such as OpenShift.
  securityContext:
    runAsUser: 0
    privileged: false
  resources:    
    limits:
      memory: "512M"
      cpu: "500m"
    requests:
      memory: "512M"
      cpu: "100m"       
# Enabling this will publicly expose your mpesa instance.
# Only enable this if you have security enabled on your cluster    
  ingress:
    enabled: false
    path: "/mpesa"
    annotations: {}
    backend: {}
  deployment:
    annotations: {}
    affinity: {}
    nodeSelector: {}
    tolerations: []
    envFrom: []
  # - configMapRef:
  #     name: config-secret
    extraEnvs: []
  # - User that the container will execute as.
  # Not necessary to run as root (0) as the mpesa Deployment use cases do not need access to Kubernetes Node internals
  # - Typically not necessarily unless running within environments such as OpenShift.
    securityContext:
      runAsUser: 0
      privileged: false
    resources:    
      limits:
        memory: "512M"
        cpu: "500m"
      requests:
        memory: "512M"
        cpu: "100m"    
# Allows you to add any config files in /usr/share/
    # such as ph-ee-connector-mpesa.yml for deployment  
    # ph-ee-connector-mpesaConfig: {}
    #   ph-ee-connector-mpesa.yml: |

roster_connector:
  enabled: false
  replicas: 1
  image: "419830066942.dkr.ecr.ap-south-1.amazonaws.com/phee-roster"
  imageTag: "v1.3.1"
  containerPort: 5000
  ams:
    local:
      enabled: ""
  pesacore:
    auth_header: ""
  livenessProbe:
    httpGet:
      path: /actuator/health/liveness
      port: 9191
    initialDelaySeconds: 120
    periodSeconds: 30
    failureThreshold: 3
    timeoutSeconds: 5 
  readinessProbe:
    httpGet:
      path: /actuator/health/readiness
      port: 9191
    initialDelaySeconds: 120
    periodSeconds: 30
    failureThreshold: 3
    timeoutSeconds: 5
# Whether this chart should self-manage its service account, role, and associated role binding.
  managedServiceAccount: true 
# Custom service account override that the pod will use
  serviceAccount: "" 
# Annotations to add to the ServiceAccount that is created if the serviceAccount value isn't set.
  serviceAccountAnnotations: {} 
# How long to wait for roster_connector pods to stop gracefully
  terminationGracePeriod: 30 
# Extra environment variables for roster_connector container.
  envFrom: [] 
  # - configMapRef:
  #     name: config-secret
  extraEnvs: []
# This is the PriorityClass settings as defined in
# https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/#priorityclass  
  priorityClassName: "" 
  # ph-ee-connector-ams-rosterConfig: ""
  #   ph-ee-connector-ams-roster.yml: |
  # - User that the container will execute as.
  # Not necessary to run as root (0) as the roster_connector Deployment use cases do not need access to Kubernetes Node internals
  # - Typically not necessarily unless running within environments such as OpenShift.
  securityContext:
    runAsUser: 0
    privileged: false
  resources:    
    limits:
      memory: "512M"
      cpu: "500m"
    requests:
      memory: "512M"
      cpu: "100m"        
  deployment:
    annotations: {}
    affinity: {}
    nodeSelector: {}
    tolerations: []
    envFrom: []
  # - configMapRef:
  #     name: config-secret
    extraEnvs: []
  # - User that the container will execute as.
  # Not necessary to run as root (0) as the roster_connector Deployment use cases do not need access to Kubernetes Node internals
  # - Typically not necessarily unless running within environments such as OpenShift.
    securityContext:
      runAsUser: 0
      privileged: false
    resources:    
      limits:
        memory: "512M"
        cpu: "500m"
      requests:
        memory: "512M"
        cpu: "100m"    
# Allows you to add any config files in /usr/share/
    # such as ph-ee-connector-ams-roster.yml for deployment  
    # ph-ee-connector-ams-rosterConfig: {}
    #   ph-ee-connector-ams-roster.yml: |
  
paygops_connector:
  enabled: false
  replicas: 1
  image: "419830066942.dkr.ecr.ap-south-1.amazonaws.com/phee-connector-ams-paygops"
  imageTag: "v1.6.1"
  containerPort: 5000
  ams:
    local:
      enabled: ""
  paygops:
    authheader: ""
  livenessProbe:
    httpGet:
      path: /actuator/health/liveness
      port: 9191
    initialDelaySeconds: 120
    periodSeconds: 30
    failureThreshold: 3
    timeoutSeconds: 5 
  readinessProbe:
    httpGet:
      path: /actuator/health/readiness
      port: 9191
    initialDelaySeconds: 120
    periodSeconds: 30
    failureThreshold: 3
    timeoutSeconds: 5
# Whether this chart should self-manage its service account, role, and associated role binding.
  managedServiceAccount: true 
# Custom service account override that the pod will use
  serviceAccount: "" 
# Annotations to add to the ServiceAccount that is created if the serviceAccount value isn't set.
  serviceAccountAnnotations: {} 
# How long to wait for paygops pods to stop gracefully
  terminationGracePeriod: 30 
# Extra environment variables for paygops container.
  envFrom: [] 
  # - configMapRef:
  #     name: config-secret
  extraEnvs: []
# This is the PriorityClass settings as defined in
# https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/#priorityclass  
  priorityClassName: "" 
  # ph-ee-connector-ams-paygopsConfig: ""
  #   ph-ee-connector-ams-paygops.yml: |
  # - User that the container will execute as.
  # Not necessary to run as root (0) as the paygops Deployment use cases do not need access to Kubernetes Node internals
  # - Typically not necessarily unless running within environments such as OpenShift.
  securityContext:
    runAsUser: 0
    privileged: false
  resources:    
    limits:
      memory: "512M"
      cpu: "500m"
    requests:
      memory: "512M"
      cpu: "100m"       
  deployment:
    annotations: {}
    affinity: {}
    nodeSelector: {}
    tolerations: []
    envFrom: []
  # - configMapRef:
  #     name: config-secret
    extraEnvs: []
  # - User that the container will execute as.
  # Not necessary to run as root (0) as the paygops Deployment use cases do not need access to Kubernetes Node internals
  # - Typically not necessarily unless running within environments such as OpenShift.
    securityContext:
      runAsUser: 0
      privileged: false
    resources:    
      limits:
        memory: "512M"
        cpu: "500m"
      requests:
        memory: "512M"
        cpu: "100m"    
# Allows you to add any config files in /usr/share/
    # such as ph-ee-connector-ams-paygops.yml for deployment  
    # ph-ee-connector-ams-paygopsConfig: {}
    #   ph-ee-connector-ams-paygops.yml: |

messagegateway:
  enabled: false
  replicas: 1
  image: docker.io/openmf/message-gateway:v1.1.0
  imagePullPolicy: "Always"
  CALLBACKCONFIG_HOST: "ph-ee-connector-notifications"
  HOSTCONFIG_HOST: "message-gateway"
  MYSQL_USERNAME: "mifos"
  MYSQL_PASSWORD: "password"
  DATASOURCE_URL: jdbc:mysql:thin://operationsmysql:3306/messagegateway
  PROVIDERSOURCE_FROMDATABASE: "disabled"
  PROVIDERSOURCE_FROMYML: "enabled"
  livenessProbe:
    httpGet:
      path: /actuator/health/liveness
      port: 9191
    initialDelaySeconds: 120
    periodSeconds: 30
    failureThreshold: 3
    timeoutSeconds: 5 
  readinessProbe:
    httpGet:
      path: /actuator/health/readiness
      port: 9191
    initialDelaySeconds: 120
    periodSeconds: 30
    failureThreshold: 3
    timeoutSeconds: 5
# Whether this chart should self-manage its service account, role, and associated role binding.
  managedServiceAccount: true 
# Custom service account override that the pod will use
  serviceAccount: "" 
# Annotations to add to the ServiceAccount that is created if the serviceAccount value isn't set.
  serviceAccountAnnotations: {} 
# How long to wait for message-gateway pods to stop gracefully
  terminationGracePeriod: 30 
# Extra environment variables for message-gateway container.
  envFrom: [] 
  # - configMapRef:
  #     name: config-secret
  extraEnvs: []
# This is the PriorityClass settings as defined in
# https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/#priorityclass  
  priorityClassName: "" 
  # ph-ee-message-gatewayConfig: ""
  #   ph-ee-message-gateway.yml: |
  # - User that the container will execute as.
  # Not necessary to run as root (0) as the message-gateway Deployment use cases do not need access to Kubernetes Node internals
  # - Typically not necessarily unless running within environments such as OpenShift.
  securityContext:
    runAsUser: 0
    privileged: false
  resources:    
    limits:
      memory: "512M"
      cpu: "500m"
    requests:
      memory: "512M"
      cpu: "100m"   
# Enabling this will publicly expose your message-gateway instance.
# Only enable this if you have security enabled on your cluster    
  ingress:
    enabled: true
    path: "/messages"
    annotations: {}
    backend: {}
  secret:
    name: ""
    key:
      telerivet_api_key: ""
    value:
      api_key: "<api_key>"
      project_id: "<project_id>"  
  deployment:
    annotations: {}
    affinity: {}
    nodeSelector: {}
    tolerations: []
    envFrom: []
  # - configMapRef:
  #     name: config-secret
    extraEnvs: []
  # - User that the container will execute as.
  # Not necessary to run as root (0) as the message-gateway Deployment use cases do not need access to Kubernetes Node internals
  # - Typically not necessarily unless running within environments such as OpenShift.
    securityContext:
      runAsUser: 0
      privileged: false
    resources:    
      limits:
        memory: "512M"
        cpu: "500m"
      requests:
        memory: "512M"
        cpu: "100m"    
# Allows you to add any config files in /usr/share/
    # such as message-gateway.yml for deployment  
    # message-gatewayConfig: {}
    #   message-gateway.yml: |

notifications:
  enabled: true
  replicas: 1
  image: docker.io/openmf/ph-ee-notifications:v1.3.0
  imagePullPolicy: "Always"
  MESSAGEGATEWAYCONFIG_HOST: "message-gateway"
  NOTIFICATION_LOCAL_HOST: "ph-ee-connector-notifications"
  NOTIFICATION_SUCCESS_ENABLED: "false"
  NOTIFICATION_FAILURE_ENABLED: "true"
  hostconfig:
    host: "message-gateway"
    port: 80
  livenessProbe:
    httpGet:
      path: /actuator/health/liveness
      port: 9191
    initialDelaySeconds: 120
    periodSeconds: 30
    failureThreshold: 3
    timeoutSeconds: 5 
  readinessProbe:
    httpGet:
      path: /actuator/health/readiness
      port: 9191
    initialDelaySeconds: 120
    periodSeconds: 30
    failureThreshold: 3
    timeoutSeconds: 5
# Whether this chart should self-manage its service account, role, and associated role binding.
  managedServiceAccount: true 
# Custom service account override that the pod will use
  serviceAccount: "" 
# Annotations to add to the ServiceAccount that is created if the serviceAccount value isn't set.
  serviceAccountAnnotations: {} 
# How long to wait for notifications pods to stop gracefully
  terminationGracePeriod: 30 
# Extra environment variables for notifications container.
  envFrom: [] 
  # - configMapRef:
  #     name: config-secret
  extraEnvs: []
# This is the PriorityClass settings as defined in
# https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/#priorityclass  
  priorityClassName: "" 
  # ph-ee-connector-notificationsConfig: ""
  #   ph-ee-connector-notifications.yml: |
  # - User that the container will execute as.
  # Not necessary to run as root (0) as the notifications Deployment use cases do not need access to Kubernetes Node internals
  # - Typically not necessarily unless running within environments such as OpenShift.
  securityContext:
    runAsUser: 0
    privileged: false
  resources:    
    limits:
      memory: "512M"
      cpu: "500m"
    requests:
      memory: "512M"
      cpu: "100m"  
# Enabling this will publicly expose your notifications instance.
# Only enable this if you have security enabled on your cluster    
  ingress:
    enabled: false
    path: "/notifications"
    annotations: {}
    backend: {}
  deployment:
    annotations: {}
    affinity: {}
    nodeSelector: {}
    tolerations: []
    envFrom: []
  # - configMapRef:
  #     name: config-secret
    extraEnvs: []
  # - User that the container will execute as.
  # Not necessary to run as root (0) as the notifications Deployment use cases do not need access to Kubernetes Node internals
  # - Typically not necessarily unless running within environments such as OpenShift.
    securityContext:
      runAsUser: 0
      privileged: false
    resources:    
      limits:
        memory: "512M"
        cpu: "500m"
      requests:
        memory: "512"
        cpu: "100m"    
# Allows you to add any config files in /usr/share/
    # such as ph-ee-connector-notifications.yml for deployment  
    # ph-ee-connector-notificationsConfig: {}
    #   ph-ee-connector-notifications.yml: |

zeebe_ops:
  enabled: false
  replicas: 1
  image: docker.io/openmf/ph-ee-zeebe-ops:v1.2.0
  imagePullPolicy: "Always"
  imagePullSecrets: []
  elasticsearch_contactpoint: "ph-ee-elasticsearch:9200"
  elasticsearch_url: "http://ph-ee-elasticsearch:9200/"
  elasticsearch_sslverification: false
  elasticsearch_security_enabled: false
  livenessProbe:
    httpGet:
      path: /actuator/health/liveness
      port: 9191
    initialDelaySeconds: 120
    periodSeconds: 30
    failureThreshold: 3
    timeoutSeconds: 5 
  readinessProbe:
    httpGet:
      path: /actuator/health/readiness
      port: 9191
    initialDelaySeconds: 120
    periodSeconds: 30
    failureThreshold: 3
    timeoutSeconds: 5
# Whether this chart should self-manage its service account, role, and associated role binding.
  managedServiceAccount: true 
# Custom service account override that the pod will use
  serviceAccount: "" 
# Annotations to add to the ServiceAccount that is created if the serviceAccount value isn't set.
  serviceAccountAnnotations: {} 
# How long to wait for Zeebe-ops pods to stop gracefully
  terminationGracePeriod: 30 
# Extra environment variables for Zeebe-ops container.
  envFrom: [] 
  # - configMapRef:
  #     name: config-secret
  extraEnvs: []
# This is the PriorityClass settings as defined in
# https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/#priorityclass  
  priorityClassName: "" 
  # ph-ee-zeebe-opsConfig: ""
  #   ph-ee-zeebe-ops.yml: |
  # - User that the container will execute as.
  # Not necessary to run as root (0) as the Zeebe-ops Deployment use cases do not need access to Kubernetes Node internals
  # - Typically not necessarily unless running within environments such as OpenShift.
  securityContext:
    runAsUser: 0
    privileged: false
  resources:    
    limits:
      memory: "512M"
      cpu: "500m"
    requests:
      memory: "512M"
      cpu: "100m" 
# Enabling this will publicly expose your zeebe_ops instance.
# Only enable this if you have security enabled on your cluster      
  ingress:
    enabled: false
    path: "/zeebeops"
    annotations: {}
    backend: {}
  deployment:
    annotations: {}
    affinity: {}
    nodeSelector: {}
    tolerations: []
    envFrom: []
  # - configMapRef:
  #     name: config-secret
    extraEnvs: []
  # - User that the container will execute as.
  # Not necessary to run as root (0) as the zeebeops Deployment use cases do not need access to Kubernetes Node internals
  # - Typically not necessarily unless running within environments such as OpenShift.
    securityContext:
      runAsUser: 0
      privileged: false
    resources:    
      limits:
        memory: "512M"
        cpu: "500m"
      requests:
        memory: "512M"
        cpu: "100m"    
# Allows you to add any config files in /usr/share/
    # such as zeebeops.yml for deployment  
    # ph-ee-zeebe-opsConfig: {}
    #   ph-ee-zeebe-ops.yml: |


importer_es:
  enabled: true
  replicas: 1
  image: docker.io/openmf/ph-ee-importer-es:v1.6.0
  imagePullPolicy: "Always"
  importer_elasticsearch_url: "http://ph-ee-elasticsearch:9200/"
  reporting:
    enabled: true
    fields:
      amount: false
      accountId: false
      ams: false
      clientCorrelationId: false
      currency: false
      customData: false
      confirmationReceived: false
      errorCode: false
      errorDescription: false
      errorInformation: false
      externalId: false
      initiator: false
      initiatorType: false
      isNotificationsFailureEnabled: false
      isNotificationsSuccessEnabled: false
      mpesaTransactionId: false
      mpesaTransactionStatusRetryCount: false
      originDate: false
      partyLookupFailed: false
      phoneNumber: false
      processDefinitionKey: false
      processInstanceKey: false
      scenario: false
      tenantId: false
      timer: false
      timestamp: false
      transactionFailed: false
      transactionId: false
      transferCreateFailed: false
      transferSettlementFailed: false
      transferResponseCREATE: false
  elasticsearch_sslverification: false
  elasticsearch_security_enabled: false
  logging:
    level:
      root: "INFO"
    pattern:
      console: "%d{dd-MM-yyyy HH:mm:ss.SSS} %magenta([%thread]) %highlight(%-5level) %logger.%M - %msg%n"
  livenessProbe:
    httpGet:
      path: /actuator/health/liveness
      port: 9191
    initialDelaySeconds: 120
    periodSeconds: 30
    failureThreshold: 3
    timeoutSeconds: 5 
  readinessProbe:
    httpGet:
      path: /actuator/health/readiness
      port: 9191
    initialDelaySeconds: 120
    periodSeconds: 30
    failureThreshold: 3
    timeoutSeconds: 5
# Whether this chart should self-manage its service account, role, and associated role binding.
  managedServiceAccount: true 
# Custom service account override that the pod will use
  serviceAccount: "" 
# Annotations to add to the ServiceAccount that is created if the serviceAccount value isn't set.
  serviceAccountAnnotations: {} 
# How long to wait for Zeebe-ops pods to stop gracefully
  terminationGracePeriod: 30 
# Extra environment variables for Zeebe-ops container.
  envFrom: [] 
  # - configMapRef:
  #     name: config-secret
  extraEnvs: []
# This is the PriorityClass settings as defined in
# https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/#priorityclass  
  priorityClassName: "" 
  # ph-ee-zeebe-opsConfig: ""
  #   ph-ee-zeebe-ops.yml: |
  # - User that the container will execute as.
  # Not necessary to run as root (0) as the Zeebe-ops Deployment use cases do not need access to Kubernetes Node internals
  # - Typically not necessarily unless running within environments such as OpenShift.
  securityContext:
    runAsUser: 0
    privileged: false
  resources:    
    limits:
      memory: "512M"
      cpu: "500m"
    requests:
      memory: "512M"
      cpu: "100m"  
  javaToolOptions: "-Xmx256M"
  deployment:
    annotations: {}



mockpayment:
  enabled: false
  image: docker.io/openmf/ph-ee-connector-mock-payment-schema:v1.4.0
  replicas: 1
  mockFailure:
    percentage: "0"
  limits:
    memory: "512M"
    cpu: "500m"
  requests:
    memory: "256M"
    cpu: "100m"
  deployment:
    annotations: {}


kafka:
  enabled: true
  fullnameOverride: kafka

  provisioning:
    enabled: true
    topics:
      - name: zeebe-export
        partitions: 1
        replicationFactor: 1

  controller:
    replicaCount: 1

  listeners:
    client:
      protocol: PLAINTEXT

    controller:
      protocol: PLAINTEXT

    interbroker:
      protocol: PLAINTEXT

    external:
      protocol: PLAINTEXT

  kraft:
    clusterId: spDnn4oSr6DLKPx3cEheLp

  # externalAccess:
  #   enabled: true
  #   autoDiscovery:
  #     enabled: true

  # rbac:
  #   create: true

  extraConfig: |
    offsets.topic.replication.factor=1
    transaction.state.log.replication.factor=1    

importer_rdbms:
  enabled: true
  replicas: 1
  image: docker.io/openmf/ph-ee-importer-rdbms:v1.7.1
  imagePullPolicy: "Always"
  SPRING_PROFILES_ACTIVE: "local,tenantsConnection"
  datasource:
      username: "mifos"
      password: "password"
      host: "operationsmysql"
      port: 3306
      schema: "tenants"
  livenessProbe:
    httpGet:
      path: /actuator/health/liveness
      port: 9191
    initialDelaySeconds: 120
    periodSeconds: 30
    failureThreshold: 3
    timeoutSeconds: 5
  readinessProbe:
    httpGet:
      path: /actuator/health/readiness
      port: 9191
    initialDelaySeconds: 120
    periodSeconds: 30
    failureThreshold: 3
    timeoutSeconds: 5
# Whether this chart should self-manage its service account, role, and associated role binding.
  managedServiceAccount: true 
# Custom service account override that the pod will use
  serviceAccount: "" 
# Annotations to add to the ServiceAccount that is created if the serviceAccount value isn't set.
  serviceAccountAnnotations: {} 
# How long to wait for importer_rdbms pods to stop gracefully
  terminationGracePeriod: 30 
# Extra environment variables for importer_rdbms container.
  envFrom: [] 
  # - configMapRef:
  #     name: config-secret
  extraEnvs: []
# This is the PriorityClass settings as defined in
# https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/#priorityclass  
  priorityClassName: "" 
  # ph-ee-importer_rdbmsConfig: ""
  #   ph-ee-importer_rdbms.yml: |
  # - User that the container will execute as.
  # Not necessary to run as root (0) as the importer_rdbms Deployment use cases do not need access to Kubernetes Node internals
  # - Typically not necessarily unless running within environments such as OpenShift.
  securityContext:
    runAsUser: 0
    privileged: false
  resources:    
    limits:
      memory: "512M"
      cpu: "500m"
    requests:
      memory: "512M"
      cpu: "100m"      
  deployment:
    annotations: {}
    affinity: {}
    nodeSelector: {}
    tolerations: []
    envFrom: []
  # - configMapRef:
  #     name: config-secret
    extraEnvs: []
  # - User that the container will execute as.
  # Not necessary to run as root (0) as the importer_rdbms Deployment use cases do not need access to Kubernetes Node internals
  # - Typically not necessarily unless running within environments such as OpenShift.
    securityContext:
      runAsUser: 0
      privileged: false
    resources:    
      limits:
        memory: "512M"
        cpu: "500m"
      requests:
        memory: "512M"
        cpu: "100m"    
# Allows you to add any config files in /usr/share/
    # such as ph-ee-importer_rdbms.yml for deployment  
    # ph-ee-importer_rdbmsConfig: {}
    #   ph-ee-importer_rdbms.yml: |
  javaToolOptions: "-Xmx256M"

connector_bulk:
  enabled: false
  replicas: 1
  image: docker.io/openmf/ph-ee-bulk-processor:v1.9.0
  imagePullPolicy: "Always"
  camel_disable_ssl: true
  channel:
    hostname: ""
  pollingApi:
    timer: "180"
  tenants: ""
  operations_app:
      contactpoint: "http://ph-ee-operations-app:5000"
      endpoints:
        batch_transaction: "/api/v1/batch/transactions"
  identity_account_mapper:
    hostname: "http://ph-ee-identity-account-mapper:80"
  config:
    partylookup:
      enable: false
    approval:
      enable: false
    ordering:
      enable: false
      field: ""
    splitting:
      enable: true
      sub_batch_size: 5
    formatting:
      enable: false
      standard: "DEFAULT"
    mergeback:
      enable: true
    backpressure:
      enable: false
    completion_threshold_check:
      enable: true
      completion_rate: 95
    deduplication:
      enabled: true  
  aws:
    access_key: "root"
    secret_key: "password"
  livenessProbe:
    httpGet:
      path: /actuator/health/liveness
      port: 9191
    initialDelaySeconds: 120
    periodSeconds: 30
    failureThreshold: 3
    timeoutSeconds: 5 
  readinessProbe:
    httpGet:
      path: /actuator/health/readiness
      port: 9191
    initialDelaySeconds: 120
    periodSeconds: 30
    failureThreshold: 3
    timeoutSeconds: 5
# Whether this chart should self-manage its service account, role, and associated role binding.
  managedServiceAccount: true 
# Custom service account override that the pod will use
  serviceAccount: "" 
# Annotations to add to the ServiceAccount that is created if the serviceAccount value isn't set.
  serviceAccountAnnotations: {} 
# How long to wait for connector_bulk pods to stop gracefully
  terminationGracePeriod: 30 
# Extra environment variables for connector_bulk container.
  envFrom: [] 
  # - configMapRef:
  #     name: config-secret
  extraEnvs: []
# This is the PriorityClass settings as defined in
# https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/#priorityclass  
  priorityClassName: "" 
  # ph-ee-connector-bulkConfig: ""
  #   ph-ee-connector-bulk.yml: |
  # - User that the container will execute as.
  # Not necessary to run as root (0) as the connector_bulk Deployment use cases do not need access to Kubernetes Node internals
  # - Typically not necessarily unless running within environments such as OpenShift.
  securityContext:
    runAsUser: 0
    privileged: false
  resources:    
    limits:
      memory: "512M"
      cpu: "500m"
    requests:
      memory: "512M"
      cpu: "100m"
  service:
    annotations: {}
# Enabling this will publicly expose your connector_bulk instance.
# Only enable this if you have security enabled on your cluster
  ingress:
    enabled: false 
    annotations: {}    
  deployment:
    annotations: {}
    affinity: {}
    nodeSelector: {}
    tolerations: []
    envFrom: []
  # - configMapRef:
  #     name: config-secret
    extraEnvs: []
  # - User that the container will execute as.
  # Not necessary to run as root (0) as the connector_bulk Deployment use cases do not need access to Kubernetes Node internals
  # - Typically not necessarily unless running within environments such as OpenShift.
    securityContext:
      runAsUser: 0
      privileged: false
    resources:    
      limits:
        memory: "512M"
        cpu: "500m"
      requests:
        memory: "512M"
        cpu: "100m"
# Allows you to add any config files in /usr/share/
    # such as ph-ee-connector-bulk.yml for deployment  
    # ph-ee-connector-bulkConfig: {}
    #   ph-ee-connector-bulk.yml: |

ph_ee_connector_gsma:
  enabled: false
  replicas: 1
  image: docker.io/openmf/ph-ee-connector-gsma:v1.2.0
  imagePullPolicy: "Always"
# Whether this chart should self-manage its service account, role, and associated role binding.
  managedServiceAccount: true 
# Custom service account override that the pod will use
  serviceAccount: "" 
# Annotations to add to the ServiceAccount that is created if the serviceAccount value isn't set.
  serviceAccountAnnotations: {} 
# How long to wait for gsma pods to stop gracefully
  terminationGracePeriod: 30 
# Extra environment variables for gsma container.
  envFrom: [] 
  # - configMapRef:
  #     name: config-secret
  extraEnvs: []
# This is the PriorityClass settings as defined in
# https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/#priorityclass  
  priorityClassName: "" 
  # ph_ee_connector_gsmaConfig: ""
  #   ph_ee_connector_gsma.yml: |
  # - User that the container will execute as.
  # Not necessary to run as root (0) as the gsma Deployment use cases do not need access to Kubernetes Node internals
  # - Typically not necessarily unless running within environments such as OpenShift.
  securityContext:
    runAsUser: 0
    privileged: false
  resources:    
    limits:
      memory: "512M"
      cpu: "500m"
    requests:
      memory: "512M"
      cpu: "100m"  
  deployment:
    annotations: {}
    affinity: {}
    nodeSelector: {}
    tolerations: []
    envFrom: []
  # - configMapRef:
  #     name: config-secret
    extraEnvs: []
  # - User that the container will execute as.
  # Not necessary to run as root (0) as the gsma Deployment use cases do not need access to Kubernetes Node internals
  # - Typically not necessarily unless running within environments such as OpenShift.
    securityContext:
      runAsUser: 0
      privileged: false
    resources:    
      limits:
        memory: "512M"
        cpu: "500m"
      requests:
        memory: "512M"
        cpu: "100m"    
# Allows you to add any config files in /usr/share/
    # such as ph_ee_connector_gsma.yml for deployment  
    # ph_ee_connector_gsmaConfig: {}
    #   ph_ee_connector_gsma.yml: |

ph-ee-connector_slcb:
  enabled: false
  replicas: 1
  image: "419830066942.dkr.ecr.ap-south-1.amazonaws.com/ph-ee-slcb"
  imageTag: "v1.4.0"
  username: "username"
  password: "password"
  signature_key: "long_segnature_key"
  auth_host: "https://g2p-test.slcb.com:8443"
  api_host: "https://g2p-test.slcb.com:8443"
  account_number: "003001003879112168"
  account_type: 0
  institutioncode: "SLCB"
  endpoint:
    auth: "/api/auth"
    transaction_request: "/api/transactionRequest"
    reconciliation: "/reconciliation"
    account_balance: "/accountBalance"
  config:
    date_format: "yyyy-MM-dd'T'hh:mm:ssXXX"
    reconciliation:
      enable: false
  livenessProbe:
    httpGet:
      path: /actuator/health/liveness
      port: 9191
    initialDelaySeconds: 120
    periodSeconds: 30
    failureThreshold: 3
    timeoutSeconds: 5 
  readinessProbe:
    httpGet:
      path: /actuator/health/readiness
      port: 9191
    initialDelaySeconds: 120
    periodSeconds: 30
    failureThreshold: 3
    timeoutSeconds: 5
# Whether this chart should self-manage its service account, role, and associated role binding.
  managedServiceAccount: true 
# Custom service account override that the pod will use
  serviceAccount: "" 
# Annotations to add to the ServiceAccount that is created if the serviceAccount value isn't set.
  serviceAccountAnnotations: {} 
# How long to wait for ph_ee_connector_slcb pods to stop gracefully
  terminationGracePeriod: 30 
# Extra environment variables for ph_ee_connector_slcb container.
  envFrom: [] 
  # - configMapRef:
  #     name: config-secret
  extraEnvs: []
# This is the PriorityClass settings as defined in
# https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/#priorityclass  
  priorityClassName: "" 
  # ph_ee_connector_slcbConfig: ""
  #   ph_ee_connector_slcb.yml: |
  # - User that the container will execute as.
  # Not necessary to run as root (0) as the ph_ee_connector_slcb Deployment use cases do not need access to Kubernetes Node internals
  # - Typically not necessarily unless running within environments such as OpenShift.
  securityContext:
    runAsUser: 0
    privileged: false
  resources:    
    limits:
      memory: "512M"
      cpu: "500m"
    requests:
      memory: "512M"
      cpu: "100m"          
  deployment:
    annotations: {}
    affinity: {}
    nodeSelector: {}
    tolerations: []
    envFrom: []
  # - configMapRef:
  #     name: config-secret
    extraEnvs: []
  # - User that the container will execute as.
  # Not necessary to run as root (0) as the ph_ee_connector_slcb Deployment use cases do not need access to Kubernetes Node internals
  # - Typically not necessarily unless running within environments such as OpenShift.
    securityContext:
      runAsUser: 0
      privileged: false
    resources:    
      limits:
        memory: "512M"
        cpu: "500m"
      requests:
        memory: "512M"
        cpu: "100m"    
# Allows you to add any config files in /usr/share/
    # such as ph_ee_connector_slcb.yml for deployment  
    # ph_ee_connector_slcbConfig: {}
    #   ph_ee_connector_slcb.yml: |

ph-ee-connector:
  enabled: false
  replicas: 1
  image: docker.io/openmf/ph-ee-connector-bulk:v1.1.0
  operations_app:
    contactpoint: "http://ph-ee-operations-app:5000"
  ingress:
    enabled: true
    annotations:
      kubernetes.io/ingress.class: nginx
    tls:
      - secretName: sandbox-secret
    hosts:
      - host: connector.sandbox.mifos.io
        paths:
          - path: "/"
            backend:
              service:
                name: ph-ee-connector
                port:
                  number: 80
  deployment:
    annotations:
      deployTime: "{{ .Values.deployTime }}"

mock_oracle:
  enabled: false
  replicas: 1
  image: "419830066942.dkr.ecr.ap-south-1.amazonaws.com/mock-asl-oracle"
  service:
    targetport: 4100
  limits:
    memory: "512M"
    cpu: "500m"
  requests:
    memory: "512M"
    cpu: "100m"
# Enabling this will publicly expose your mock_oracle instance.
# Only enable this if you have security enabled on your cluster    
  ingress:
    enabled: true
    path: "/"
    annotations: {}
    backend: {}
  deployment:
    annotations: {}

keycloak:
  enabled: false
  fullnameOverride: "keycloak"
# Enabling this will publicly expose your keycloak instance.
# Only enable this if you have security enabled on your cluster
  ingress:
    enabled: false
    ingressClassName: "kong"
    rules:
      - host: 'keycloak.mifos.io'
    tls: []
  postgresql:
    initdbUser: "keycloak"
    initdbPassword: "keycloak"
    initdbScripts:
      my_init_script.sql: |-
          CREATE DATABASE kong;
  extraVolumes: |
    - name: realm-secret
      secret:
        secretName: realm-secret
  extraVolumeMounts: |
    - name: realm-secret
      mountPath: "/realm/"
      readOnly: true
  extraEnv: |
    - name: KEYCLOAK_IMPORT
      value: /realm/kong-keycloak-realm.json     

integration_test:
  enabled: false
  replicas: 1
  image: "docker.io/openmf/ph-ee-integration-test:latest"
  imageTag: v1.4.0-rc.1
  imagePullPolicy: "Never"
  limits:
    cpu: "500m"
    memory: "3Gi"
  requests:
    cpu: "100m"
    memory: "2Gi"
  operations_app:
    contactpoint: "http://ph-ee-operations-app:80"
  bulk_processor:
    contactpoint: "https://ph-ee-connector-bulk:8443"
  channel_connector:
    contactpoint: "https://ph-ee-connector-channel:8443"
  kafka:
    brokers: ""
    topics: ""
    consumerTimeoutMs: ""
  zeebe_operations:
    contactpoint: ""
    no_of_workflows: ""
    thread-count: ""
  max_retry_count: ""
  retry_intervals: ""
  defaults:
    tenant: ""
    authorization: ""
  channel:
    base_url: ""
  loan:
    base_url: ""
  savings:
    base_url: ""
  gradle:
    command: ""

redis:
  enabled: true
  replica:
    replicaCount: 1
volumeClaimTemplate:
    storageClassName: "gp2"

kong:
  enabled: false
  image:
    repository: revomatico/docker-kong-oidc
    tag: "latest"
  migrations:
    init: true
    preUpgrade: false
    postUpgrade: false
  env:
    plugins: "bundled,oidc"
    database: "postgres"
    pg_host: "g2p-sandbox-security-postgresql"
    pg_user: "keycloak"
    pg_password: "keycloak"
    pg_database: "kong"
  admin:
    enabled: true
    http:
      enabled: true
    tls:
      enabled: false
# Enabling this will publicly expose your kong instance.
# Only enable this if you have security enabled on your cluster      
    ingress:
      enabled: true
      ingressClassName: "kong"
      hostname: kong-admin.mifos.io
  extraObjects:
    - apiVersion: configuration.konghq.com/v1
      kind: KongClusterPlugin
      metadata:
        name: request-transformer
        annotations:
          kubernetes.io/ingress.class: "kong"
        labels:
          global: "false"
      disabled: false # optionally disable the plugin in Kong
      plugin: request-transformer
      config:
        remove:
          headers:
            - cookie
            - x-id-token
    - apiVersion: configuration.konghq.com/v1
      kind: KongClusterPlugin
      metadata:
        name: cors
        annotations:
          kubernetes.io/ingress.class: "kong"
        labels:
          global: "true"
      disabled: false # optionally disable the plugin in Kong
      plugin: cors
      config:
        origins:
          - "*"
        credentials: true
        max_age: 3600
        exposed_headers :
          - "*"
        preflight_continue: false
    - apiVersion: configuration.konghq.com/v1
      kind: KongClusterPlugin
      metadata:
        name: oidc
        annotations:
          kubernetes.io/ingress.class: "kong"
        labels:
          global: "false"
      disabled: false # optionally disable the plugin in Kong
      plugin: oidc
      config: # configuration for the plugin
        realm: Kong
        discovery: https://keycloak.localhost/auth/realms/kong-oidc/.well-known/openid-configuration
        scope: openid
        introspection_endpoint: http://keycloak.localhost/auth/realms/Kong/protocol/openid-connect/token/introspect
        redirect_after_logout_uri: http://keycloak.localhost/auth/realms/kong-oidc/protocol/openid-connect/logout?redirect_uri=http://keycloak.localhost

    

vouchers:
  enabled: false
  paymentadvice: false
  replicas: 1
  image: docker.io/openmf/ph-ee-vouchers:v1.1.0
  ingress:
    enabled: true
    annotations:
      kubernetes.io/ingress.class: nginx
    tls:
      - secretName: sandbox-secret
    hosts:
      - host: vouchers.sandbox.mifos.io
        paths:
          - path: "/"
            backend:
              service:
                name: ph-ee-vouchers
                port:
                  number: 80
  deployment:
    annotations:
      deployTime: "{{ .Values.deployTime }}"
  spring:
    datasource:
      url: jdbc:mysql://operationsmysql:3306/voucher_management
      username: mifos
      password: password
  async:
    core_pool_size: 10
    max_pool_size: 10
    queue_capacity: 100
  expiry_time: 60
  payer:
    tenant: rhino
    identifier: 12345678
    identifierType: MSISDN
  salting:
    enabled: true
  identity-account-mapper:
    hostname: "https://ph-ee-identity-mapper:80"
  operations:
    hostname: "http://ph-ee-operations-app:80"
    endpoints:
      transfers: "/api/v1/transfers?size=1&page=0"

billPay:
  enabled: false
  replicas: 1
  image: docker.io/openmf/ph-ee-bill-pay:v1.0.0
  imagePullPolicy: "Always"
  connector:
    contactpoint: "http://ph-ee-connector:80"
  billpay:
    contactpoint: "http://ph-ee-connector-bill-pay:8080"
  livenessProbe:
    httpGet:
      path: /actuator/health/liveness
      port: 8080
      scheme: HTTPS
    initialDelaySeconds: 120
    periodSeconds: 30
    failureThreshold: 3
    timeoutSeconds: 5
  readinessProbe:
    httpGet:
      path: /actuator/health/readiness
      port: 8080
      scheme: HTTPS
    initialDelaySeconds: 120
    periodSeconds: 30
    failureThreshold: 3
    timeoutSeconds: 5
  # Whether this chart should self-manage its service account, role, and associated role binding.
  managedServiceAccount: true
  # Custom service account override that the pod will use
  serviceAccount: "billPay"
  # Annotations to add to the ServiceAccount that is created if the serviceAccount value isn't set.
  serviceAccountAnnotations: {}
  # How long to wait for pods to stop gracefully
  terminationGracePeriod: 30
  # Extra environment variables for container.
  envFrom: []
  # - configMapRef:
  #     name: config-secret
  extraEnvs: []
  # This is the PriorityClass settings as defined in
  # https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/#priorityclass
  priorityClassName: ""
  securityContext:
    runAsUser: 0
    privileged: false
  resources:
    limits:
      memory: "512M"
      cpu: "500m"
    requests:
      memory: "512M"
      cpu: "100m"
  service:
    annotations: {}
  # Only enable this if you have security enabled on your cluster
  ingress:
    enabled: true
    path: "/billPay"
    annotations: {}
    backend: {}
    stub_backend: {}
  deployment:
    annotations: {}
    affinity: {}
    nodeSelector: {}
    tolerations: []
    envFrom: []
    # - configMapRef:
    #     name: config-secret
    extraEnvs: []
    # - User that the container will execute as.
    # - Typically not necessarily unless running within environments such as OpenShift.

crm:
  enabled: false
  replicas: 1
  image: docker.io/openmf/ph-ee-connector-crm:v1.0.0
  imagePullPolicy: "Always"
  livenessProbe:
    httpGet:
      path: /actuator/health/liveness
      port: 8080
      scheme: HTTPS
    initialDelaySeconds: 120
    periodSeconds: 30
    failureThreshold: 3
    timeoutSeconds: 5
  readinessProbe:
    httpGet:
      path: /actuator/health/readiness
      port: 8080
      scheme: HTTPS
    initialDelaySeconds: 120
    periodSeconds: 30
    failureThreshold: 3
    timeoutSeconds: 5
  # Whether this chart should self-manage its service account, role, and associated role binding.
  managedServiceAccount: true
  # Custom service account override that the pod will use
  serviceAccount: "crm"
  # Annotations to add to the ServiceAccount that is created if the serviceAccount value isn't set.
  serviceAccountAnnotations: {}
  # How long to wait for pods to stop gracefully
  terminationGracePeriod: 30
  # Extra environment variables for container.
  envFrom: []
  # - configMapRef:
  #     name: config-secret
  extraEnvs: []
  # This is the PriorityClass settings as defined in
  # https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/#priorityclass
  priorityClassName: ""
  securityContext:
    runAsUser: 0
    privileged: false
  resources:
    limits:
      memory: "512M"
      cpu: "500m"
    requests:
      memory: "512M"
      cpu: "100m"
  service:
    annotations: {}
  # Only enable this if you have security enabled on your cluster
  ingress:
    enabled: true
    path: "/crm"
    annotations: {}
    backend: {}
    stub_backend: {}
  deployment:
    annotations: {}
    affinity: {}
    nodeSelector: {}
    tolerations: []
    envFrom: []
    # - configMapRef:
    #     name: config-secret
    extraEnvs: []
    # - User that the container will execute as.
    # - Typically not necessarily unless running within environments such as OpenShift.
minio:
  enabled: true
  fullnameOverride: "minio"
  resources:
    requests:
      memory: 256Mi
  replicas: 1
  persistence:
    enabled: true
    size: 10Gi
  mode: standalone
  rootUser: root
  rootPassword: password
  buckets:
    - name: paymenthub-ee
      policy: public

post_installation_job:
  enabled: false
